<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crop Tool</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
      cursor: default;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.8);
      padding: 5px;
    }
    body.dragover::after {
      content: 'Drop image here';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-weight: bold;
      z-index: 999;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="fileInput" />
    <select id="presetSelect"></select>
    <button id="saveBtn">Crop & Save</button>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const fileInput = document.getElementById("fileInput");
    const presetSelect = document.getElementById("presetSelect");
    const saveBtn = document.getElementById("saveBtn");
    let rotation = 0; // in radians
    let rotationDragging = false;
    let rotationHandleRadius = 8; // size of rotation handle
    let rotationHandleDistance = 30; // distance from crop box edge    

    let image = null;
    let imageFilename = "image";
    let imageMimeType = "image/jpeg"; // default    
    let scale = 1;
    let crop = { x: 0, y: 0, size: 10 };
    let dragging = false;
    let resizing = false;
    let dragOffset = { x: 0, y: 0 };
    let currentPreset = null;

    const resizeHandleSize = 20;

    const presets = {
      passport: {
        label: "Passport",
        outer: [4.0, 4.0], // printed size (inches)
        inner: [2.0, 2.0], // cut size (inches)
        extra: [1.25, 1.25] // face size (inches)
      },
      pawpals: {
        label: "Pawpals",
        outer: [4.0, 4.0], // printed size (inches)
        inner: [3.0, 3.75] // cut size (inches)
        // no extra
      },
      heart_locket: {
        label: "Heart Locket",
        outer: [4.0, 4.0], // printed size (inches)
        polygons: [
          [[ 0.6403, -0.0000], [ 0.7575, -0.2030], [ 0.7575, -0.4373], [ 0.6403, -0.6403], [ 0.4373, -0.7575], [ 0.2030, -0.7575], [ 0.0000, -0.6403], [ 0.0000, -0.6403], [-0.2030, -0.7575], [-0.4373, -0.7575], [-0.6403, -0.6403], [-0.7575, -0.4373], [-0.7575, -0.2030], [-0.6403, -0.0000], [-0.2784,  0.3619], [ 0.2784,  0.3619], [ 0.6403, -0.0000]]
        ]
      },
      heart_locket2: {
        label: "Heart Locket 2x2",
        outer: [2.0, 2.0], // half printed size (inches) (for printing a 2x2 collage)
        polygons: [
          [[ 0.6403, -0.0000], [ 0.7575, -0.2030], [ 0.7575, -0.4373], [ 0.6403, -0.6403], [ 0.4373, -0.7575], [ 0.2030, -0.7575], [ 0.0000, -0.6403], [ 0.0000, -0.6403], [-0.2030, -0.7575], [-0.4373, -0.7575], [-0.6403, -0.6403], [-0.7575, -0.4373], [-0.7575, -0.2030], [-0.6403, -0.0000], [-0.2784,  0.3619], [ 0.2784,  0.3619], [ 0.6403, -0.0000]]
        ]
      }
    };

   for (const key in presets) {
      const opt = document.createElement("option");
      opt.value = key;
      opt.textContent = presets[key].label;
      presetSelect.appendChild(opt);
    }

    presetSelect.addEventListener("change", () => {
      const previousPreset = currentPreset;
      currentPreset = presets[presetSelect.value];
      if (previousPreset) {
        // Keep the physical size constant
        const [prevW, prevH] = previousPreset.outer;
        const [newW, newH] = currentPreset.outer;
        const prevArea = prevW * prevH;
        const newArea = newW * newH;
        const factor = Math.sqrt(prevArea / newArea);
        crop.size *= factor;
      }
      draw();
    });

    function loadImageFile(file) {
      if (!file || !file.type.startsWith('image/')) return;

      imageFilename = file.name.replace(/\.[^/.]+$/, "");
      imageMimeType = file.type || "image/png";

      const reader = new FileReader();
      reader.onload = function(evt) {
        const img = new Image();
        img.onload = function() {
          image = img;
          resizeCanvas();
          resetCrop();
          draw();
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    }

    fileInput.addEventListener("change", e => {
      const file = e.target.files[0];
      if (file) loadImageFile(file);
    });

    // Drag and drop support
    document.body.addEventListener("dragover", e => {
      e.preventDefault();
      e.stopPropagation();
      document.body.classList.add('dragover');
    });

    document.body.addEventListener("dragleave", e => {
      e.preventDefault();
      e.stopPropagation();
      // Only remove if leaving the body itself
      if (e.target === document.body) {
        document.body.classList.remove('dragover');
      }
    });

    document.body.addEventListener("drop", e => {
      e.preventDefault();
      e.stopPropagation();
      document.body.classList.remove('dragover');

      const file = e.dataTransfer.files[0];
      if (file) loadImageFile(file);
    });

    window.addEventListener("resize", () => {
      resizeCanvas();
      draw();
    });

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (image) {
        const scaleX = canvas.width / image.width;
        const scaleY = canvas.height / image.height;
        scale = Math.min(scaleX, scaleY);
      }
    }

    function resetCrop() {
      if (!currentPreset) {
        crop.size = Math.min(image.width, image.height) * 0.5;
      } else {
        const [ow, oh] = currentPreset.outer;
        // Calculate size that fits within the image with some margin
        const maxWidth = image.width * 0.8; // 80% of image width
        const maxHeight = image.height * 0.8; // 80% of image height
        
        // Find the size that fits both width and height constraints
        const sizeForWidth = maxWidth / ow;
        const sizeForHeight = maxHeight / oh;
        crop.size = Math.min(sizeForWidth, sizeForHeight);
      }
      
      // Center the crop area
      const [ow, oh] = currentPreset ? currentPreset.outer : [1, 1];
      const cropWidth = crop.size * ow;
      const cropHeight = crop.size * oh;
      crop.x = (image.width - cropWidth) / 2;
      crop.y = (image.height - cropHeight) / 2;
    }

    function toScreen(x, y) {
      const dx = (canvas.width - image.width * scale) / 2;
      const dy = (canvas.height - image.height * scale) / 2;
      return { x: x * scale + dx, y: y * scale + dy };
    }

    function toImage(x, y) {
      const dx = (canvas.width - image.width * scale) / 2;
      const dy = (canvas.height - image.height * scale) / 2;
      return { x: (x - dx) / scale, y: (y - dy) / scale };
    }

    canvas.addEventListener("mousedown", e => {
      const { x, y } = toImage(e.offsetX, e.offsetY);
      const [ow, oh] = currentPreset.outer;
      const boxW = crop.size * ow;
      const boxH = crop.size * oh;

      // Check rotation handle first
      const centerX = crop.x + boxW / 2;
      const centerY = crop.y + boxH / 2;
      const handleX = centerX + Math.cos(rotation) * (boxW / 2 + rotationHandleDistance / scale);
      const handleY = centerY + Math.sin(rotation) * (boxW / 2 + rotationHandleDistance / scale);
      
      const distToRotationHandle = Math.sqrt((x - handleX) ** 2 + (y - handleY) ** 2);
      
      if (distToRotationHandle <= rotationHandleRadius / scale) {
        rotationDragging = true;
        return;
      }      

      // Transform mouse coordinates to account for rotation when checking resize handle
      const cos = Math.cos(-rotation); // negative because we're inverse transforming
      const sin = Math.sin(-rotation);
      const relX = x - centerX;
      const relY = y - centerY;
      const unrotatedX = centerX + (relX * cos - relY * sin);
      const unrotatedY = centerY + (relX * sin + relY * cos);      


      const resizeX = crop.x + boxW;
      const resizeY = crop.y + boxH;
      if (
        unrotatedX >= resizeX - resizeHandleSize / scale &&
        unrotatedX <= resizeX &&
        unrotatedY >= resizeY - resizeHandleSize / scale &&
        unrotatedY <= resizeY
      ) {
        resizing = true;
        return
      }
      
      if (
        unrotatedX >= crop.x && unrotatedX <= crop.x + boxW &&
        unrotatedY >= crop.y && unrotatedY <= crop.y + boxH
      ) {
        dragging = true;
        dragOffset = { x: unrotatedX - crop.x, y: unrotatedY - crop.y };
      }
    });

    canvas.addEventListener("mousemove", e => {
      const { x, y } = toImage(e.offsetX, e.offsetY);
      const [ow, oh] = currentPreset.outer;
      const boxW = crop.size * ow;
      const boxH = crop.size * oh;
      const resizeX = crop.x + boxW;
      const resizeY = crop.y + boxH;
      const centerX = crop.x + boxW / 2;
      const centerY = crop.y + boxH / 2;      

      if (rotationDragging) {
        // Calculate angle from center to mouse
        const angle = Math.atan2(y - centerY, x - centerX);
        rotation = angle;
        canvas.style.cursor = "grabbing";
        draw();
        return;
      }
      
      if (dragging) {
        // Transform mouse coordinates for dragging
        const cos = Math.cos(-rotation);
        const sin = Math.sin(-rotation);
        const relX = x - centerX;
        const relY = y - centerY;
        const unrotatedX = centerX + (relX * cos - relY * sin);
        const unrotatedY = centerY + (relX * sin + relY * cos);
        
        crop.x = unrotatedX - dragOffset.x;
        crop.y = unrotatedY - dragOffset.y;
        draw();
        return;
      }

      if (resizing) {
        // Transform mouse coordinates for resizing
        const cos = Math.cos(-rotation);
        const sin = Math.sin(-rotation);
        const relX = x - centerX;
        const relY = y - centerY;
        const unrotatedX = centerX + (relX * cos - relY * sin);
        const unrotatedY = centerY + (relX * sin + relY * cos);
        
        const dx = unrotatedX - crop.x;
        const dy = unrotatedY - crop.y;
        const newSize = Math.max(dx / ow, dy / oh);
        crop.size = newSize;
        draw();
        return;
      }
      
      // Transform coordinates for hover detection
      const cos = Math.cos(-rotation);
      const sin = Math.sin(-rotation);
      const relX = x - centerX;
      const relY = y - centerY;
      const unrotatedX = centerX + (relX * cos - relY * sin);
      const unrotatedY = centerY + (relX * sin + relY * cos);
      

      // Check if hovering over rotation handle
      const handleX = centerX + Math.cos(rotation) * (boxW / 2 + rotationHandleDistance / scale);
      const handleY = centerY + Math.sin(rotation) * (boxW / 2 + rotationHandleDistance / scale);
      const distToRotationHandle = Math.sqrt((x - handleX) ** 2 + (y - handleY) ** 2);
      
      if (distToRotationHandle <= rotationHandleRadius / scale) {
        canvas.style.cursor = "grab";
        return;
      }

      if (
        unrotatedX >= resizeX - resizeHandleSize / scale &&
        unrotatedX <= resizeX &&
        unrotatedY >= resizeY - resizeHandleSize / scale &&
        unrotatedY <= resizeY
      ) {
        canvas.style.cursor = "nwse-resize";
      } else {
        canvas.style.cursor = dragging ? "grabbing" : "default";
      }

      if (dragging) {
        crop.x = unrotatedX - dragOffset.x;
        crop.y = unrotatedY - dragOffset.y;
        draw();
      } else if (resizing) {
        const dx = unrotatedX - crop.x;
        const dy = unrotatedY - crop.y;
        const newSize = Math.max(dx / ow, dy / oh);
        crop.size = newSize;
        draw();
      }
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
      resizing = false;
      rotationDragging = false;
    });

    saveBtn.addEventListener("click", () => {
      if (!image || !currentPreset) return;
      const [ow, oh] = currentPreset.outer;
      const w = crop.size * ow;
      const h = crop.size * oh;
      const temp = document.createElement("canvas");
      temp.width = w;
      temp.height = h;
      const tctx = temp.getContext("2d");
      tctx.drawImage(image, crop.x, crop.y, w, h, 0, 0, w, h);
      const link = document.createElement("a");
      
      let mime = (imageMimeType === "image/jpeg" || imageMimeType === "image/png")
             ? imageMimeType
             : "image/png"; // only allow safe types
      let ext = mime === "image/jpeg" ? "jpg" : "png";
      link.href = temp.toDataURL(mime, 0.92);
      link.download = `${imageFilename}-cropped.${ext}`;
      link.click();
    });

    function draw() {
      if (!image || !currentPreset) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const dx = (canvas.width - image.width * scale) / 2;
      const dy = (canvas.height - image.height * scale) / 2;
      ctx.drawImage(image, dx, dy, image.width * scale, image.height * scale);

      const [ow, oh] = currentPreset.outer;
      const s = crop.size;
      const sx = crop.x, sy = crop.y;
      const outerW = s * ow;
      const outerH = s * oh;
      const centerX = sx + outerW / 2;
      const centerY = sy + outerH / 2;
      const scrCenter = toScreen(centerX, centerY);

      // Apply rotation transform around center
      ctx.save();
      ctx.translate(scrCenter.x, scrCenter.y);
      ctx.rotate(rotation);
      ctx.translate(-scrCenter.x, -scrCenter.y);

      // Draw all overlay elements (boxes, polygons, etc.)
      const scr = toScreen(sx, sy);
      
      // DPI calculation based on actual pixel dimensions
      const dpiX = outerW / ow;
      const dpiY = outerH / oh;
      const dpi = Math.round((dpiX + dpiY) / 2);

      // Red outer box
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(scr.x, scr.y, outerW * scale, outerH * scale);

      ctx.fillStyle = 'black';
      ctx.font = '14px sans-serif';

      ctx.shadowColor = "black";
      ctx.shadowBlur = 2;
      ctx.lineWidth = 2;
      ctx.fillText(`${ow}" × ${oh}" @ ${dpi} DPI`, scr.x + 4, scr.y - 8);
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'white';
      ctx.fillText(`${ow}" × ${oh}" @ ${dpi} DPI`, scr.x + 4, scr.y - 8);

      // Blue inner box
      if (currentPreset.inner) {
        const [iw_inches, ih_inches] = currentPreset.inner;
        const iw = outerW * (iw_inches / ow);
        const ih = outerH * (ih_inches / oh);
        const iScr = toScreen(sx + (outerW - iw) / 2, sy + (outerH - ih) / 2);
        ctx.strokeStyle = 'blue';
        ctx.strokeRect(iScr.x, iScr.y, iw * scale, ih * scale);
      }

      // Optional green extra box
      if (currentPreset.extra) {
        const [ew_inches, eh_inches] = currentPreset.extra;
        const ew = outerW * (ew_inches / ow);
        const eh = outerH * (eh_inches / oh);
        const eScr = toScreen(sx + (outerW - ew) / 2, sy + (outerH - eh) / 2);
        ctx.strokeStyle = 'green';
        ctx.strokeRect(eScr.x, eScr.y, ew * scale, eh * scale);
      }

      // custom polygons
      if (currentPreset.polygons) {
        ctx.strokeStyle = 'purple';
        ctx.lineWidth = 2;
        currentPreset.polygons.forEach(polygon => {
          ctx.beginPath();
          polygon.forEach((pt, idx) => {
            const px = sx + (pt[0] * s) + outerW / 2;
            const py = sy + (pt[1] * s) + outerH / 2;
            const scrPt = toScreen(px, py);
            if (idx === 0) {
              ctx.moveTo(scrPt.x, scrPt.y);
            } else {
              ctx.lineTo(scrPt.x, scrPt.y);
            }
          });
          ctx.closePath();
          ctx.stroke();
        });
      }

      // Resize handle (triangle)
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(scr.x + outerW * scale, scr.y + outerH * scale);
      ctx.lineTo(scr.x + outerW * scale - resizeHandleSize, scr.y + outerH * scale);
      ctx.lineTo(scr.x + outerW * scale, scr.y + outerH * scale - resizeHandleSize);
      ctx.closePath();
      ctx.fill();

      ctx.restore(); // Restore transform

      // Draw rotation handle (outside of rotation transform)
      const handleX = centerX + Math.cos(rotation) * (outerW / 2 + rotationHandleDistance / scale);
      const handleY = centerY + Math.sin(rotation) * (outerW / 2 + rotationHandleDistance / scale);
      const scrHandle = toScreen(handleX, handleY);
      
      ctx.fillStyle = 'orange';
      ctx.strokeStyle = 'darkorange';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(scrHandle.x, scrHandle.y, rotationHandleRadius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      
      // Optional: draw line from center to handle
      ctx.strokeStyle = 'orange';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(scrCenter.x, scrCenter.y);
      ctx.lineTo(scrHandle.x, scrHandle.y);
      ctx.stroke();
      ctx.setLineDash([]);      
    }

    currentPreset = presets[presetSelect.value];
  </script>
</body>
</html>
